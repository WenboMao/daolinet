import webob
from webob import exc

from nova.api.openstack import extensions
from nova.api.openstack import wsgi
from nova import exception
from nova.i18n import _
from nova import objects

from oslo_config import cfg
from oslo_log import log as logging
from novaclient.client import HTTPClient

CONF = cfg.CONF
CONF.register_opt(cfg.StrOpt('controller_api',
                             default='http://127.0.0.1:8081',
                             help='The openflow controller api.'))

LOG = logging.getLogger(__name__)
authorize = extensions.extension_authorizer('compute', 'daolicloud')

class GatewayController(object):

    def index(self, req):
        """Returns all the gateways."""
        ctxt = req.environ['nova.context']
        gateways = objects.GatewayList.get_all(ctxt)
        return {'gateways': gateways}

class GroupController(wsgi.Controller):
    """The VPCs API."""

    def index(self, req):
        ctxt = req.environ['nova.context']
        groups = objects.GroupList.get_by_project(ctxt, ctxt.project_id)
        return {'groups': groups}

    def show(self, req, id):
        ctxt = req.environ['nova.context']
        group = objects.Group.get(ctxt, id)
        return {'group': group}

    def create(self, req, body):
        if not self.is_valid_body(body, 'group'):
            raise exc.HTTPUnprocessableEntity()

        ctxt = req.environ['nova.context']
        group = body['group']
        group_obj = objects.Group.create(ctxt,
                                         group['name'],
                                         group['description'],
                                         group['project_id'])
        return {'group': group_obj}

    def delete(self, req, id):
        ctxt = req.environ['nova.context']
        objects.Group.delete(ctxt, id)


    #def update(self, req, id, body):
    #    """Update vpc items."""
    #    if not self.is_valid_body(body, 'group'):
    #        raise exc.HTTPUnprocessableEntity()

    #    ctxt = req.environ['nova.context']
    #    group = body['group']

    #    if group['action'] == 'delete':
    #        try:
    #            client = HTTPClient(ctxt.user_name,
    #                                ctxt.auth_token,
    #                                bypass_url=CONF.controller_api,
    #                                auth_token=ctxt.auth_token)
    #            client.put('/v1.0/group', body={'sid': group['start'],
    #                                            'did': group['end']})
    #        except Exception as e:
    #            LOG.error(e.message)

    #    if hasattr(objects.Group, group['action']):
    #        project_id = id or ctxt.project_id
    #        getattr(objects.Group, group['action'])(ctxt,
    #            project_id, group['start'], group['end'])

    #    return webob.Response(status_int=202)

class GroupMemberController(wsgi.Controller):
    """The VPCs Member API."""

    def show(self, req, id):
        ctxt = req.environ['nova.context']
        members = objects.GroupMemberList.get(ctxt, id)
        return {'members': members}

    def update(self, req, body):
        if not self.is_valid_body(body, 'member'):
            raise exc.HTTPUnprocessableEntity()

        ctxt = req.environ['nova.context']

        action = body['member'].get('action')
        if not action:
            raise webob.exc.HTTPBadRequest(explanation='Action is not empty')
        group_id = body['member']['group_id']
        instance_id = body['member']['instance_id']

        if objects.GroupMember, '
        group_member = objects.GroupMember.create(ctxt,
            group_id=member['group_id'], instance_id=member['instance_id'])

        return {'group_member': group_member}

    def delete(self, req, id):
        ctxt = req.environ['nova.context']
        objects.GroupMember.delete(ctxt, group_id=group_id,)


class FirewallController(wsgi.Controller):

    def show(self, req, id):
        ctxt = req.environ['nova.context']
        firewalls = objects.FirewallList.get_by_instance(ctxt, id)
        return {'firewalls': firewalls}

    def create(self, req, body):
        if not self.is_valid_body(body, 'firewall'):
            raise exc.HTTPUnprocessableEntity()

        ctxt = req.environ['nova.context']
        params = body['firewall']

        if not params.has_key('fake_zone'):
            params['fake_zone'] = False

        firewall = objects.Firewall.create(ctxt, **params)

        return {'firewall': firewall}

    def delete(self, req, id):
        ctxt = req.environ['nova.context']
        objects.Firewall.delete(ctxt, id)
        return webob.Response(status_int=202)

    def action(self, req, id, body):
        if not self.is_valid_body(body, 'firewall'):
            raise exc.HTTPUnprocessableEntity()

        ctxt = req.environ['nova.context']
        params = body['firewall']

        try: 
            objects.Firewall.get(ctxt, hostname=params['hostname'],
                                 gateway_port=params['gateway_port'])
            msg = _("This gateway port already be in used.")
            raise exc.HTTPConflict(explanation=msg)
            #return webob.Response(status_int=409)
        except exception.SecurityGroupNotFoundForRule:
            return webob.Response(status_int=202)

class Os_daolicloud(extensions.ExtensionDescriptor):
    """Daolicloud Extension."""

    name = "Daolicloud"
    alias = "os-daolicloud"
    namespace = "http://www.daolicloud.com"
    updated = "2015-10-21T00:00:00Z"

    def get_resources(self):
        member_actions = {'action': 'POST'}
        resources = []
        resource = extensions.ResourceExtension('os-gateways',
                                                GatewayController())
        resources.append(resource)
        resource = extensions.ResourceExtension('os-groups',
                                                GroupController())
        resources.append(resource)
        resource = extensions.ResourceExtension('os-firewalls',
                                                FirewallController(),
                                                member_actions=member_actions)
        resources.append(resource)
        return resources
